/**
 * TOPICS DATABASE SERVICE - SUPABASE INTEGRATION
 * 
 * PURPOSE: Manages topics storage, retrieval, and editing in Supabase database
 * 
 * DATABASE INTEGRATION:
 * This service interfaces with the 'topics' table in Supabase, which stores
 * consumer perception topics generated by AI or created by users.
 * 
 * TABLE STRUCTURE (topics):
 * - topic_id: UUID (primary key)
 * - audit_id: UUID (foreign key to audit table)
 * - topic_name: VARCHAR (topic name)
 * - topic_type: VARCHAR (topic description, nullable)
 * - visibility: INTEGER (visibility level, nullable)
 */

import { supabase } from "@/integrations/supabase/client";
import { Topic } from "@/types/brandTypes";
import { v4 as uuidv4 } from 'uuid';

// API Configuration
const API_BASE_URL = 'http://localhost:8000/api';

// Backend API interfaces for topics updates
export interface TopicUpdateApiRequest {
  name?: string;
  description?: string;
}

export interface TopicUpdateApiResponse {
  success: boolean;
  message: string;
  topic?: {
    id: string;
    name: string;
    description: string;
    category: string;
  };
  errors?: string[];
}

/**
 * TYPE DEFINITION: Database Topic Record
 * 
 * Represents the exact structure of topics table in Supabase
 * Used for type safety in database operations
 */
export interface DatabaseTopic {
  topic_id: string;              // UUID primary key
  audit_id: string;              // Links to specific audit
  topic_name: string;            // Topic title
  topic_type: string | null;     // Topic description (nullable)
  topic_category: 'unbranded' | 'branded' | 'comparative'; // Topic category
  visibility: number | null;     // Visibility level (nullable)
}

/**
 * TYPE DEFINITION: Topic with Metadata
 * 
 * Extended topic interface with metadata
 */
export interface TopicWithMetadata extends Topic {
  editedByUser?: boolean;
  createdAt?: string;
  updatedAt?: string;
}

/**
 * TYPE DEFINITION: Store Topics Request
 * 
 * Contains all data needed to store topics in database
 * Includes audit context and topic source information
 */
export interface StoreTopicsRequest {
  auditId: string;               // Links topics to specific audit
  topics: Topic[];               // Topics to store
  source: 'ai' | 'user';         // Whether topics came from AI or user input
  replaceExisting?: boolean;     // Whether to replace existing topics (default: false)
}

/**
 * TYPE DEFINITION: Update Topic Request
 * 
 * Data needed to update a single topic
 * Automatically marks topic as edited by user
 */
export interface UpdateTopicRequest {
  topicId: string;               // ID of topic to update
  name?: string;                 // New name (optional)
  description?: string;          // New description (optional)
  auditId: string;               // Audit ID for validation
}

/**
 * TYPE DEFINITION: Service Response
 * 
 * Standardized response format for all service operations
 * Provides consistent error handling and success feedback
 */
export interface TopicsServiceResponse<T = any> {
  success: boolean;
  data?: T;                      // Response data (if successful)
  error?: string;                // Error message (if failed)
  count?: number;                // Number of affected records
}

/**
 * HELPER FUNCTION: Convert Database Topic to App Topic
 * 
 * PURPOSE: Transform database records to application format
 * USAGE: Used when retrieving topics from database
 * 
 * @param dbTopic - Topic record from database
 * @returns Topic in application format
 */
function databaseTopicToAppTopic(dbTopic: DatabaseTopic): TopicWithMetadata {
  return {
    id: dbTopic.topic_id,
    name: dbTopic.topic_name,
    description: dbTopic.topic_type || '', // Handle null values
    category: dbTopic.topic_category, // Add category field
    editedByUser: false, // We'll track this in app state
    createdAt: undefined, // Database doesn't have timestamp fields
    updatedAt: undefined  // Database doesn't have timestamp fields
  };
}

/**
 * HELPER FUNCTION: Convert App Topic to Database Topic
 * 
 * PURPOSE: Transform application topics to database format
 * USAGE: Used when storing topics in database
 * 
 * @param topic - Topic in application format
 * @param auditId - Audit ID to link topic to
 * @returns Topic record for database insertion
 */
function appTopicToDatabaseTopic(
  topic: Topic, 
  auditId: string
): DatabaseTopic {
  return {
    topic_id: topic.id || uuidv4(),
    audit_id: auditId,
    topic_name: topic.name.trim(),
    topic_type: topic.description?.trim() || '',
    topic_category: topic.category, // Add category field
    visibility: 1 // Default visibility
  };
}

/**
 * MAIN FUNCTION: Store Topics in Database
 * 
 * PURPOSE: Save generated or user-created topics to Supabase
 * 
 * FEATURES:
 * - Batch insertion for efficiency
 * - Duplicate prevention
 * - Transaction-like behavior (all or nothing)
 * - Automatic UUID generation for topics without IDs
 * 
 * WORKFLOW:
 * 1. Validate audit ID and topics
 * 2. Transform topics to database format
 * 3. Handle existing topics (replace or skip)
 * 4. Insert new topics in database
 * 5. Return stored topics with database IDs
 * 
 * @param request - Topics and audit context
 * @returns Promise with stored topics or error
 */
export async function storeTopics(request: StoreTopicsRequest): Promise<TopicsServiceResponse<Topic[]>> {
  try {
    const { auditId, topics, source, replaceExisting = false } = request;
    
    // VALIDATION 1: Check required parameters
    if (!auditId || !auditId.trim()) {
      return {
        success: false,
        error: 'Audit ID is required'
      };
    }
    
    if (!topics || !Array.isArray(topics) || topics.length === 0) {
      return {
        success: false,
        error: 'At least one topic is required'
      };
    }
    
    console.log(`üíæ Storing ${topics.length} topics for audit:`, auditId);
    
    // STEP 1: Handle existing topics if replacement requested
    if (replaceExisting) {
      console.log('üóëÔ∏è Removing existing topics for audit:', auditId);
      
      const { error: deleteError } = await supabase
        .from('topics')
        .delete()
        .eq('audit_id', auditId);
      
      if (deleteError) {
        console.error('‚ùå Error deleting existing topics:', deleteError);
        return {
          success: false,
          error: `Failed to delete existing topics: ${deleteError.message}`
        };
      }
    }
    
    // STEP 2: Prepare topics for database insertion
    const topicsToInsert = topics.map(topic => appTopicToDatabaseTopic(topic, auditId));
    
        // STEP 3: Insert topics in database    // Handle RLS by ensuring user context (development workaround)    const { data: { user } } = await supabase.auth.getUser();    if (!user) {      console.log('üîß No authenticated user found - topics may fail due to RLS policy');      console.log('üí° Consider signing in or disabling RLS on topics table for development');    }
    
    const { data: insertedTopics, error: insertError } = await supabase
      .from('topics')
      .insert(topicsToInsert)
      .select('*');
    
    if (insertError) {
      console.error('‚ùå Error inserting topics:', insertError);
      return {
        success: false,
        error: `Failed to store topics: ${insertError.message}`
      };
    }
    
    if (!insertedTopics) {
      return {
        success: false,
        error: 'No topics were inserted'
      };
    }
    
    // STEP 4: Convert inserted topics back to app format
    const storedTopics = insertedTopics.map(databaseTopicToAppTopic);
    
    console.log(`‚úÖ Successfully stored ${storedTopics.length} topics for audit:`, auditId);
    
    return {
      success: true,
      data: storedTopics,
      count: storedTopics.length
    };
    
  } catch (error) {
    console.error('‚ùå Unexpected error storing topics:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred'
    };
  }
}

/**
 * MAIN FUNCTION: Get Topics for Audit
 * 
 * PURPOSE: Retrieve all topics associated with a specific audit
 * 
 * FEATURES:
 * - Automatic sorting by creation date
 * - Empty result handling
 * - Comprehensive error handling
 * 
 * @param auditId - Audit ID to get topics for
 * @returns Promise with topics or error
 */
export async function getTopicsForAudit(auditId: string): Promise<TopicsServiceResponse<TopicWithMetadata[]>> {
  try {
    // VALIDATION: Check audit ID
    if (!auditId || !auditId.trim()) {
      return {
        success: false,
        error: 'Audit ID is required'
      };
    }
    
    console.log('üì• Retrieving topics for audit:', auditId);
    
    // QUERY: Get topics from database
    const { data: topics, error } = await supabase
      .from('topics')
      .select('*')
      .eq('audit_id', auditId)
      .order('topic_id', { ascending: true });
    
    if (error) {
      console.error('‚ùå Error retrieving topics:', error);
      return {
        success: false,
        error: `Failed to retrieve topics: ${error.message}`
      };
    }
    
    // HANDLE: Empty results
    if (!topics || topics.length === 0) {
      console.log('‚ÑπÔ∏è No topics found for audit:', auditId);
      return {
        success: true,
        data: [],
        count: 0
      };
    }
    
    // TRANSFORM: Convert to app format
    const appTopics = topics.map(databaseTopicToAppTopic);
    
    console.log(`‚úÖ Retrieved ${appTopics.length} topics for audit:`, auditId);
    
    return {
      success: true,
      data: appTopics,
      count: appTopics.length
    };
    
  } catch (error) {
    console.error('‚ùå Unexpected error retrieving topics:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred'
    };
  }
}

/**
 * MAIN FUNCTION: Update Single Topic
 * 
 * PURPOSE: Update specific fields of a topic in database
 * 
 * FEATURES:
 * - Partial updates (only changed fields)
 * - Automatic timestamp updates
 * - User edit tracking
 * - Validation and error handling
 * 
 * @param request - Topic update data
 * @returns Promise with updated topic or error
 */
export async function updateTopicRequest(request: UpdateTopicRequest): Promise<TopicsServiceResponse<TopicWithMetadata>> {
  try {
    const { topicId, name, description, auditId } = request;
    
    // VALIDATION: Check required parameters
    if (!topicId || !topicId.trim()) {
      return {
        success: false,
        error: 'Topic ID is required'
      };
    }
    
    if (!auditId || !auditId.trim()) {
      return {
        success: false,
        error: 'Audit ID is required'
      };
    }
    
    if (!name && !description) {
      return {
        success: false,
        error: 'At least one field (name or description) must be provided for update'
      };
    }
    
    console.log('üìù Updating topic via backend API:', topicId);
    
    // PREPARE: Update data for backend API
    const updateRequest: TopicUpdateApiRequest = {};
    
    if (name !== undefined) {
      updateRequest.name = name.trim();
    }
    
    if (description !== undefined) {
      updateRequest.description = description.trim();
    }
    
    // CALL: Backend API to update topic
    const response = await fetch(`${API_BASE_URL}/topics/${topicId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updateRequest),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
      return {
        success: false,
        error: `API error: ${response.status} - ${errorData.detail || 'Topic update failed'}`
      };
    }

    const apiResponse: TopicUpdateApiResponse = await response.json();
    
    if (!apiResponse.success) {
      return {
        success: false,
        error: apiResponse.message || 'Topic update failed'
      };
    }
    
    if (!apiResponse.topic) {
      return {
        success: false,
        error: 'Topic data not returned from API'
      };
    }
    
    // TRANSFORM: Convert API response to app format
    const updatedTopic: TopicWithMetadata = {
      id: apiResponse.topic.id,
      name: apiResponse.topic.name,
      description: apiResponse.topic.description,
      category: apiResponse.topic.category as 'unbranded' | 'branded' | 'comparative',
      editedByUser: true, // Mark as user-edited
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    console.log('‚úÖ Successfully updated topic via API:', topicId);
    
    return {
      success: true,
      data: updatedTopic
    };
    
  } catch (error) {
    console.error('‚ùå Unexpected error updating topic:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred'
    };
  }
}

/**
 * MAIN FUNCTION: Delete Topic
 * 
 * PURPOSE: Remove a specific topic from database
 * 
 * FEATURES:
 * - Audit validation for security
 * - Confirmation of deletion
 * - Error handling
 * 
 * @param topicId - ID of topic to delete
 * @param auditId - Audit ID for validation
 * @returns Promise with success status or error
 */
export async function deleteTopic(topicId: string, auditId: string): Promise<TopicsServiceResponse<void>> {
  try {
    // VALIDATION: Check required parameters
    if (!topicId || !topicId.trim()) {
      return {
        success: false,
        error: 'Topic ID is required'
      };
    }
    
    if (!auditId || !auditId.trim()) {
      return {
        success: false,
        error: 'Audit ID is required'
      };
    }
    
    console.log('üóëÔ∏è Deleting topic:', topicId);
    
    // DELETE: Topic from database
    const { error } = await supabase
      .from('topics')
      .delete()
      .eq('topic_id', topicId)
      .eq('audit_id', auditId); // Extra security: ensure topic belongs to audit
    
    if (error) {
      console.error('‚ùå Error deleting topic:', error);
      return {
        success: false,
        error: `Failed to delete topic: ${error.message}`
      };
    }
    
    console.log('‚úÖ Successfully deleted topic:', topicId);
    
    return {
      success: true
    };
    
  } catch (error) {
    console.error('‚ùå Unexpected error deleting topic:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred'
    };
  }
}

/**
 * UTILITY FUNCTION: Check if Topics Exist for Audit
 * 
 * PURPOSE: Verify if audit already has topics without retrieving them
 * USAGE: Used to determine if topics need to be generated or loaded
 * 
 * @param auditId - Audit ID to check
 * @returns Promise with existence status and count
 */
export async function checkTopicsExist(auditId: string): Promise<TopicsServiceResponse<{ exists: boolean; count: number }>> {
  try {
    if (!auditId || !auditId.trim()) {
      return {
        success: false,
        error: 'Audit ID is required'
      };
    }
    
    console.log('üîç Checking topics existence for audit:', auditId);
    
    const { count, error } = await supabase
      .from('topics')
      .select('topic_id', { count: 'exact', head: true })
      .eq('audit_id', auditId);
    
    if (error) {
      console.error('‚ùå Error checking topics existence:', error);
      return {
        success: false,
        error: `Failed to check topics existence: ${error.message}`
      };
    }
    
    const topicsCount = count || 0;
    const exists = topicsCount > 0;
    
    console.log(`‚úÖ Topics check complete - Exists: ${exists}, Count: ${topicsCount}`);
    
    return {
      success: true,
      data: {
        exists,
        count: topicsCount
      }
    };
    
  } catch (error) {
    console.error('‚ùå Unexpected error checking topics existence:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred'
    };
  }
}

/**
 * SIMPLIFIED FUNCTIONS FOR FRONTEND COMPONENT COMPATIBILITY
 * 
 * These functions provide a simpler interface for the frontend components
 * while using the robust service functions internally
 */

/**
 * SIMPLE: Save Topics
 */
export async function saveTopics(auditId: string, topics: Topic[]): Promise<void> {
  const result = await storeTopics({
    auditId,
    topics,
    source: 'ai',
    replaceExisting: true
  });
  
  if (!result.success) {
    throw new Error(result.error || 'Failed to save topics');
  }
}

/**
 * SIMPLE: Get Topics
 */
export async function getTopics(auditId: string): Promise<TopicWithMetadata[]> {
  const result = await getTopicsForAudit(auditId);
  
  if (!result.success) {
    throw new Error(result.error || 'Failed to get topics');
  }
  
  return result.data || [];
} 